# 🧩 Software Development Life Cycle(SDLC)
It is used by many Software Companies such as Google,Microsoft,wipro,Tcs etc so that the development process will be easier without any of the following issues  
🐞 Bugs  
💰 Cost  
🚀 Launch the product fast  
⚙️ Making the process small and easier  
🎯 To make the product that is Suitable to the goal(Users)  
   <details>
      ![SDLC Diagram](https://github.com/LikhithAvinash/Computer_Science_Notes/blob/master/Software_Engineering/assets/SDLC.png)
    </details>
    
👆 The above reason is why the SDLC is created
In this there are 2 types  
a) Traditional b) Evolutionary 

### 🏗️ Traditional ###
These models follow a strict, step-by-step process. You must finish one phase completely before moving on to the next.  

i) **Waterfall model:** It's a linear, sequential flow where progress moves steadily downwards (like a waterfall) through the phases of requirements, design, implementation, testing, and maintenance.  
<details>![Waterfall](https://github.com/LikhithAvinash/Computer_Science_Notes/blob/master/Software_Engineering/assets/waterfall.png)</details>

ii) **V-Model:** This is an extension of the Waterfall model. For every development phase (like design), there is a corresponding testing phase (like test design) running in parallel. It places a strong emphasis on testing.  

### 🔁 Evolutionary
They involve building the software in small, repeated cycles (iterations), allowing for flexibility and feedback.

**Agile:** It is a Concept that is of short development "sprints" to deliver working software quickly. Common Agile frameworks include  
    **i) Scrum:** Focuses on managing work in short, timed iterations. For each sprint it should mainly have 'working model'.

**Prototype Model:** This model involves building a "prototype" (a mock-up or early version) of the software to show to the user. This is great for gathering early feedback on requirements before building the full, final product.

**Incremental Model:** In this model, the product is designed and built in "increments" (pieces). Each increment adds more functionality. The first increment might just be the user login, the second adds profile viewing, the third adds editing, etc

**Spiral Model:** Each loop of the spiral has four simple steps:  
    Stage_1: Plan: Figure out what you're going to do in this loop (the goals, the features).  
    Stage_2: Risk Analysis: Ask, "What is the biggest thing that could make this project fail?" (e.g., the technology is too slow, the budget is too small, etc.).  
    Stage_3: Build: Make a small version (a prototype) of the product that specifically tests and solves that big risk.  
    Stage_4: Review: Show the prototype to the client/user. Do they like it? Did it solve the risk? What should we do in the next loop? 
    
   <details>![Spiral Model](https://github.com/LikhithAvinash/Computer_Science_Notes/blob/master/Software_Engineering/assets/spiral.png)</details>

### ⚖️ Traditional vs Evolutionary
<details>
   <summary>Traditional vs Evolutionary</summary>
   <img width="675" height="899" alt="Traditional vs Evolutionary" src="https://github.com/user-attachments/assets/cd2fcf0a-1f24-4f4c-9b80-b1491d7ba11c" />
</details>

<details>
  <summary>📊 Traditional Models Example</summary>
  <img 
    src="https://github.com/LikhithAvinash/Computer_Science_Notes/blob/master/Software_Engineering/assets/traditional.png?raw=true" 
    alt="Traditional vs Evolutionary Models" 
    width="675" 
    height="899" 
  />
</details>

<details>
  <summary>📈 Evolutionary Models Example</summary>
  <img 
    src="https://github.com/LikhithAvinash/Computer_Science_Notes/blob/master/Software_Engineering/assets/Evolutionary.png?raw=true" 
    alt="Evolutionary Models" 
    width="675" 
    height="899" 
  />
</details>










